<link rel="import" href="../../styles/shared.html">
<link rel="import" href="../base/base.html">
<link rel="import" href="../dialog/dialog-mixin.html">
<link rel="import" href="../icon/icon.html">
<link rel="import" href="../input/input.html">
<link rel="import" href="../loading-button/loading-button.html">
<link rel="import" href="../locale/locale.html">
<link rel="import" href="../notification/notification.html">
<link rel="import" href="../toggle/toggle-button.html">

<dom-module id="pl-cloud-view">

    <template>

        <style include="shared">
            :host {
                display: flex;
                flex-direction: column;
                @apply --fullbleed;
            }

            button, pl-toggle-button {
                display: block;
                width: 100%;
                box-sizing: border-box;
            }

            .note {
                font-size: var(--font-size-tiny);
                padding: 15px;
                text-align: center;
            }

            .conn-id {
                margin-top: 10px;
                font-weight: bold;
            }

            #emailInput {
                text-align: center;
            }

            #customUrlInput {
                width: 100%;
                padding-left: 15px;
                padding-right: 15px;
            }

            #customUrlInput:not([invalid]) + .warning {
                display: none;
            }

            @media (min-width: 700px) {
                pl-icon[icon=backward] {
                    display: none;
                }
            }
        </style>


        <header class="tiles">
            <pl-icon icon="backward" class="tap" on-click="_back"></pl-icon>
            <div class="title">Padlock Cloud</div>
            <pl-icon icon="refresh" class="tap" on-click="synchronize"></pl-icon>
        </header>

        <main>

            <section class="tiles tiles-2" hidden$="[[ _isSet(settings.syncToken) ]]">
                <div class="note">
                    [[ _generalInfoText() ]]
                </div>
                <pl-input id="emailInput" type="email" placeholder="[[ $l('Enter Email Address') ]]" value="[[ settings.syncEmail ]]" required on-enter="connect"></pl-input>
                <pl-loading-button id="connectButton" class="tap" label="[[ $l('Get Started') ]]" on-click="connect"></pl-loading-button>
            </section>

            <section class="tiles tiles-2" hidden$="[[ !_isActivationPending(settings.syncToken, settings.syncConnected) ]]">
                <div class="note">
                    <strong>[[ $l("Activation pending") ]]</strong> -
                    [[ _activationPendingText(settings.syncEmail) ]]
                    <div class="conn-id">[[ $l("Connection ID: {0}", settings.syncId) ]]</div>
                </div>
                <button class="tap" on-click="_cancelConnect">[[ $l("Cancel") ]]</button>
            </section>

            <section class="tiles tiles-2" hidden$="[[ !_isTrialing(settings.syncConnected, settings.syncSubStatus) ]]">
                <div class="note">
                    <strong>[[ $l("Your trial period ends in {0} days.", _remainingTrialDays) ]]</strong> -
                    [[ _trialInfoText() ]]
                </div>
                <button class="tap" on-click="_openDashboard">[[ $l("Manage Subscriptions") ]]</button>
            </section>

            <section class="tiles tiles-2" hidden$="[[ !_isInactive(settings.syncConnected, settings.syncSubStatus) ]]">
                <div class="note">
                    <strong>[[ $l("Read-Only") ]]</strong> -
                    [[ _readOnlyInfoText() ]]
                </div>
                <button class="tap" on-click="_openDashboard">[[ $l("Manage Subscriptions") ]]</button>
            </section>

            <section class="tiles tiles-2" hidden$="[[ !settings.syncConnected ]]">
                <div class="note">
                    <strong>[[ $l("Connected") ]]</strong> -
                    [[ _connectedInfoText(settings.syncEmail) ]]
                    <div class="conn-id">[[ $l("Connection ID: {0}", settings.syncId) ]]</div>
                </div>
                <pl-loading-button id="syncButton" class="tap" on-click="synchronize" label="[[ $l('Synchronize') ]]"></pl-loading-button>
                <button class="tap" on-click="_openDashboard">[[ $l("Manage Account") ]]</button>
                <button class="tap" on-click="_disconnect">[[ $l("Disconnect") ]]</button>
                <pl-toggle-button active="{{ settings.syncAuto }}" label="[[ $l('Auto Sync') ]]" reverse class="tap"></pl-toggle-button>
            </section>

            <section class="tiles tiles-2">
                <div class="note">
                    [[ $l("By providing a custom URL you can synchronize your data with a server other than the official Padlock Cloud server.") ]]
                    <strong>[[ $l("WARNING: This is only recommended for advanced users!") ]]</strong>
                </div>
                <pl-toggle-button active="{{ settings.syncCustomHost }}" label="[[ $l('Use Custom Server') ]]" reverse
                    on-change="_customHostChanged" class="tap"></pl-toggle-button>
                <div class="tap tiles" hidden$="[[ !settings.syncCustomHost ]]">
                    <pl-input id="customUrlInput" placeholder="[[ $l('Enter Custom URL') ]]"
                        value="{{ settings.syncHostUrl }}" pattern="^https://[^\s/$.?#].[^\s]*$"
                        required></pl-input>
                    <div class="note warning">
                        <strong>[[ $l("Invalid URL") ]]</strong> -
                        [[ $l("Make sure that the URL is of the form https://myserver.tld:port. Note that a https connection is required.") ]]
                    </div>
                </div>
            </section>

        </main>

    </template>

    <script>
(() => {

class CloudView extends padlock.LocaleMixin(padlock.DialogMixin(padlock.NotificationMixin(padlock.BaseElement))) {

    static get is() { return "pl-cloud-view"; }

    static get properties() { return {
        cloudSource: Object,
        collection: {
            type: Object,
            notify: true
        },
        localSource: Object,
        settings: {
            type: Object,
            notify: true
        },
        _remainingTrialDays: {
            type: Number,
            computed: "_computeRemainingTrialDays(settings.syncTrialEnd)"
        }
    }; }

    static get observers() { return [
        "_credentialsChanged(settings.syncToken, settings.syncConnected)"
    ]; }

    synchronize() {
        if (!this.settings.syncConnected) {
            this.alert($l("You have to be connected to a Padlock Cloud account to synchronize your data!"))
                .then(() => this.$.emailInput.focus());
            return Promise.reject();
        }

        if (this._chainedSync) {
            // There is already a chained sync promise, so just return that one
            return this._chainedSync;
        }

        if (this._currentSync) {
            // There is already a synchronization in process. wait for the current sync to finish
            // before starting a new one.
            const chained = this._chainedSync = this._currentSync
                .then(() => {
                    this._chainedSync = null;
                    return this.synchronize();
                });
            return chained;
        }

        const sync = this._currentSync = this._synchronize()
            .then(() => this._currentSync = null, () => this._currentSync = null);
        return sync;
    }

    _back() {
        this.dispatchEvent(new CustomEvent("cloud-back"));
    }

    _disconnect() {
        this.confirm(
            $l("Are you sure you want to disconnect from Padlock Cloud?"),
            $l("Disconnect")
        ).then((confirmed) => {
            if (confirmed) {
                this.settings.syncConnected = false;
                this.settings.syncToken = "";
                this.settings.syncEmail = "";
                this.settings.syncReadonly = false;
                this.notifyPath("settings");
            }
        });
    }

    connect() {
        if (this.$.emailInput.invalid) {
            this.alert(this.$.emailInput.validationMessage || $l("Please enter a valid email address!"));
        } else {
            this._requestAuthToken(this.$.emailInput.value.toLowerCase());
        }
    }

    //* Requests an api key from the cloud api with the entered email and device name
    _requestAuthToken(email, create) {
        this.$.connectButton.start();
        this.settings.email = email;
        this.settings.syncToken = "";
        this.notifyPath("settings");

        this.cloudSource.source.requestAuthToken(email, create)
            .then((authToken) => {
                // We're getting back the api key directly, but it will valid only
                // after the user has visited the activation link in the email he was sent
                this.settings.syncConnected = false;
                this.settings.syncToken = authToken.token;
                this.settings.syncId = authToken.id;
                this.notifyPath("settings");
                this.$.connectButton.success();
                this.alert(this._activationPendingText());
            })
            .catch((e) => {
                switch (typeof e === "string" ? e : e.code) {
                    case "account_not_found":
                        this._requestAuthToken(email, true);
                        break;
                    case "rate_limit_exceeded":
                        this.$.connectButton.fail();
                        this.alert($l("For security reasons only a limited amount of connection request " +
                            "are allowed at a time. Please wait a little before trying again!"));
                        break;
                    default:
                        this.$.connectButton.fail();
                        this.alert($l("Something went wrong. Please try again later!"));
                }
                this.notifyPath("settings");
            });
    }

    _isTrialing(connected, s) {
        return connected && s == "trialing";
    }

    _isInactive(connected, s) {
        return connected && s && s != "active" && s != "trialing";
    }

    _isSet(val) {
        return !!val;
    }

    _synchronize() {
        this.$.syncButton.start();
        return this.collection.fetch(this.cloudSource)
            .then(() => this.collection.save(this.localSource))
            .then(() => this.collection.save(this.cloudSource))
            .then(() => {
                this.notifyPath("collection");
                this.notifyPath("settings");
                this.$.syncButton.success();

                if (this.localSource.password !== this.cloudSource.password) {
                    return this.confirm(
                        $l("Do you want to change your Padlock Cloud master password to your local one?"),
                        $l("Yes"), $l("No")
                    ).then((confirm) => {
                        if (confirm) {
                            this.$.syncButton.start();
                            this.cloudSource.password = this.localSource.password;
                            return this.collection.save(this.cloudSource)
                                .then(() => {
                                    this.$.syncButton.success();
                                    this.alert($l("Padlock Cloud master password updated successfully!"));
                                })
                                .catch(() => {
                                    this.$.syncButton.fail();
                                    this.alert($l("Failed to update Padlock Cloud " +
                                        "master password. Please try again later!"));
                                });
                        }
                    });
                }
            })
            .catch((e) => {
                this.notifyPath("settings");
                this.$.syncButton.fail();
                this._handleCloudError(e);
            });
    }

    _handleCloudError(e) {
        switch (e.code) {
            case "account_not_found":
            case "invalid_auth_token":
            case "expired_auth_token":
                this.settings.syncConnected = false;
                this.settings.syncToken = "";
                this.settings.syncEmail = "";
                this.settings.syncReadonly = false;
                this.notifyPath("settings");
                this.alert($l("There was a problem authenticating with Padlock Cloud. Please " +
                    "complete the connection process again!"));
                break;
            case "deprecated_api_version":
                this.confirm(
                    $l("A newer version of Padlock is available now! You can download it using the " +
                    "button below. Please note that you won't be able to use Padlock Cloud until " +
                    "you install the latest version!"),
                    $l("Update Now"),
                    $l("Dismiss")
                ).then((confirm) => {
                    if (confirm) {
                        window.open(padlock.platform.getAppStoreLink(), "_system");
                    }
                });
                break;
            case "rate_limit_exceeded":
                this.alert($l("It seems Padlock Cloud is over capacity right now. Please try again later!"));
                break;
            case "json_error":
            case "invalid_container_data":
            case "invalid_key_params":
                this.alert($l(
                    "The data received from Padlock Cloud seems to be corrupt and " +
                    "cannot be decrypted. This might be due to a network error but could " +
                    "also be the result of someone trying to compromise your connection to " +
                    "Padlock Cloud. If the problem persists, please notify " +
                    "Padlock support!"
                ));
                break;
            case "decryption_failed":
            case "encryption_failed":
                // Decryption failed. This means that the local master
                // password does not match the one that was used for encrypting the remote data so
                // we need to prompt the user for the correct password.
                this.prompt(
                    $l("It seems that your Padlock Cloud account uses a different master " +
                    "password than then one you are using on this device. Please provide the " +
                    "correct master password for your Padlock Cloud account!"),
                    $l("Enter Master Password"), "password", $l("Submit"))
                    .then((pwd) => {
                        if (pwd === null) {
                            return;
                        }

                        this.cloudSource.password = pwd;
                        this.synchronize();
                    });
                break;
            case "subscription_required":
                this.alert($l(
                    "You currently don't have an active subscription which means you can access " +
                    "your existing data on Padlock Cloud but you won't be able to upload any new data " +
                    "or synchronize changes between devices. Get a subscription now to regain full access " +
                    "to Padlock Cloud!"
                ));
                break;
            default:
                this.alert($l("Something went wrong. Please try again later!"));
        }
    }

    _connectionSuccess() {
        this.confirm(
            $l("You successfully paired this device with Padlock Cloud!"),
            $l("Synchonize Now"), $l("Dismiss")
        )
            .then((confirmed) => {
                if (confirmed) {
                    this.synchronize();
                }
            });
    }

    _customHostChanged() {
        if (this.settings.syncCustomHost) {
            this.confirm(
                $l("Are you sure you want to use a custom server for synchronization? " +
                    "This option is only recommended for advanced users!"),
                $l("Continue"))
                .then((confirmed) => {
                    if (!confirmed) {
                        this.set("settings.syncCustomHost", false);
                    }
                });
        }
    }

    _cancelConnect() {
        this.set("settings.syncToken", "");
    }

    _openDashboard() {
        window.open(this.settings.syncHostUrl + "/dashboard/", "_system");
    }

    _computeRemainingTrialDays(trialEnd) {
        var now = new Date().getTime() / 1000;
        trialEnd = trialEnd ? parseInt(trialEnd, 10) : now;
        return Math.ceil((trialEnd - now) / 60 / 60 / 24);
    }

    _testCredentials(pollInterval) {
        if (this._testCredsPromise || !this._isActivationPending()) {
            return;
        }

        this._testCredsPromise = this.cloudSource.source.testCredentials()
            .then((connected) => {
                this._testCredsPromise = null;
                this.settings.syncConnected = connected;
                this.notifyPath("settings");

                if (connected) {
                    this._connectionSuccess();
                }

                if (!connected && pollInterval) {
                    setTimeout(() => this._testCredentials(pollInterval), pollInterval);
                }
            })
            .catch((e) => {
                this._testCredsPromise = null;
                this._handleCloudError(e);
            });
    }

    _credentialsChanged() {
        if (this._isActivationPending()) {
            // Wait 1 minute, then poll every 10 seconds
            setTimeout(() => this._testCredentials(10000), 60000);
            // Also test on first focus event since there is a chance the user is just returning
            // from his email client / web browsers
            window.addEventListener("focus", () => this._testCredentials(), { once: true });
        }
    }

    _isActivationPending() {
        return this.settings.syncToken && !this.settings.syncConnected;
    }

    _generalInfoText() {
        return $l(
            "Padlock Cloud provides a convenient way of synchronising your data between " +
            "all your devices. By securely storing your data in the cloud, it not only allows you " +
            "to easily access it from anywhere but also acts as a backup in case you should lose " +
            "your device or accidentally erase your data. Before being sent to our servers, " +
            "your data is encrypted locally using your master password to make sure that nobody " +
            "can read it - not even we!"
        );
    }

    _trialInfoText() {
        return $l(
            "After this period, your access will be read-only, which means you will be able to access " +
            "your existing data on Padlock Cloud but you won't be able to upload any new data or synchronize " +
            "changes between devices. Get a subscription now to get unlimited access to Padlock Cloud!"
        );
    }

    _readOnlyInfoText() {
        return $l(
            "You currently don't have an active subscription! This means you can access " +
            "your existing data on Padlock Cloud but you won't be able to upload any new data " +
            "or synchronize changes between devices. Get a subscription now to regain full access " +
            "to Padlock Cloud!"
        );
    }

    _connectedInfoText() {
        return $l(
            "This device is connected to the Padlock Cloud account {0}. Connect all your devices " +
            "with the same account to easily synchronize your data between them!",
            this.settings.syncEmail
        );
    }

    _activationPendingText() {
        return $l(
            "You are almost done connecting this device. An email was sent to {0}. Check your " +
            "inbox and follow the instructions to complete the process!",
            this.settings.syncEmail
        );
    }

}

window.customElements.define(CloudView.is, CloudView);

})();
    </script>

</dom-module>
