<link rel="import" href="../base/base.html">
<link rel="import" href="../generator/generator.html">
<link rel="import" href="dialog-alert.html">
<link rel="import" href="dialog-confirm.html">
<link rel="import" href="dialog-prompt.html">
<link rel="import" href="dialog-options.html">

<script>
((dialog) => {

const { wait } = padlock.util;

const dialogElements = {};

let lastDialogPromise = Promise.resolve();
let currentDialog;


padlock.DialogMixin = (superClass) => {

    return class DialogMixin extends superClass {

        getDialog(elName) {
            let el = dialogElements[elName];

            if (!el) {
                dialogElements[elName] = el = document.createElement(elName);
                document.body.appendChild(el);
            }

            return el;
        }

        lineUpDialog(dialog, fn) {
            dialog = typeof dialog === "string" ? this.getDialog(dialog) : dialog;
            const promise = lastDialogPromise
                .then(() => {
                    currentDialog = dialog;
                    return fn(dialog);
                });

            lastDialogPromise = promise
                .then(() => wait(500));

            return promise;
        }

        alert(message, buttonLabel) {
            return this.lineUpDialog("pl-dialog-alert", (dialog) => dialog.alert(message, buttonLabel));
        }

        confirm(message, confirmLabel, cancelLabel) {
            return this.lineUpDialog("pl-dialog-confirm", (dialog) => dialog.confirm(message, confirmLabel, cancelLabel));
        }

        prompt(message, placeholder, type, confirmLabel, cancelLabel, preventDismiss, verify) {
            return this.lineUpDialog("pl-dialog-prompt", (dialog) => {
                return dialog.prompt(message, placeholder, type, confirmLabel, cancelLabel, preventDismiss, verify);
            });
        }

        choose(message, options, preventDismiss=true) {
            return this.lineUpDialog("pl-dialog-options", (dialog) => {
                dialog.preventDismiss = preventDismiss;
                return dialog.choose(message, options);
            });
        }

        generate() {
            return this.lineUpDialog("pl-generator", (dialog) => dialog.generate());
        }

        getSingleton(elName) {
            return this.getDialog(elName);
        }

        clearDialogs() {
            if (currentDialog) {
                currentDialog.open = false;
            }
            lastDialogPromise = Promise.resolve();
        }

        promptPassword(password, msg, confirmLabel, cancelLabel) {
            return this.prompt(msg, $l("Enter Password"), "password", confirmLabel, cancelLabel, true, (pwd) => {
                if (!pwd) {
                    return Promise.reject($l("Please enter a password!"));
                } else if (pwd !== password) {
                    return Promise.reject($l("Wrong password. Please try again!"));
                } else {
                    return Promise.resolve(true);
                }
            });
        }

        promptForgotPassword() {
            return this.confirm($l(
                "Forgot your password? For security reasons don't keep a record of your master " +
                "password so unfortunately we cannot help you recover it. You can reset your password, " +
                "but your data will be lost in the process."
            ), $l("Reset Password"), $l("Keep Trying"))
                .then((confirmed) => {
                    return confirmed && this.confirm($l(
                        "Are you sure you want to reset your password? " +
                        "WARNING: All your data will be lost!"
                    ), $l("Reset Password"));
                });
        }

    };
};

})();
</script>
